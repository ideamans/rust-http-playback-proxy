# 使用技術

- Rust

# コマンドインターフェース

- 録画モード
  - `http-playback-proxy recording [entry_url] --port <port>--device <desktop|mobile> --inventory <inventory_dir>`
- 再生モード
  - `http-playback-proxy playback --port <port> --inventory <inventory_dir>`
- デフォルト値
  - ポート: 8080 から順に空きポートを探索して利用
  - デバイス: mobile
  - インベントリ: ./inventory

# データ型

- @reference/types.ts を参照。
- Resource と Inventory については、これらの型と強い互換性を求める。
- それ以外の型については、処理を高速に進めるために最適化してよい。

# このプログラムは

- MITM プロキシとして動作する
  - HTTPS にも対応しますが、すべての自己署名証明書を用い、HTTPS エラーはすべて無意する
- 録画モード
  - HTTP プロキシを起動する
  - 最初のリクエスト受信を起点(0 秒)とする
  - レスポンスはストリーム状にブラウザにも送信する
  - 同時にメモリに記録する
    - リクエストから応答受信開始までの時間(ttfb)
    - メソッド・ステータスコード・ヘッダ・レスポンスボディ
      - レスポンスボディは圧縮されている場合はそのまま
    - レスポンスボディの長さと、応答受信開始から完了までの時間
  - 録画終了は Ctrl+C で行う
  - 録画が終了したら、プロセス終了までの間に Inventory の保存を行う
    - Inventory は inventory_dir/inventory.json として保存する
    - レスポンスボディはエンコーディングを解凍して、inventory_dir/contents/<method>/<protocol>/<path> に保存する
      - <path>は URL のパス構造を用いるが、インデックス(/で終わる場合)は index.html を補う
      - URL パラメータは次のルールでファイル名に付与する
        - パラメータが 32 文字以内の場合はエンコードしてそのまま。ベース名と拡張子の間に~をつけてファイル名にする
          - 例: `https://example.com/path/to/resource?param=value` は `resource~param=value.html`
        - パラメータが 32 文字を超える場合は、32 文字目以降を sha1 でハッシュ化し、前半 32 文字に付加してファイル名にする
          - 例: `https://example.com/path/to/resource?param=verylongvalue....` は `resource~param=verylongvalue.~<sha1(32文字名以降)>.html`
    - レスポンスボディが主要なテキストリソースの場合、UTF8 に変換する
      - 主要なテキストリソース: HTML、CSS、JavaScript
      - ヘッダの Charset またはリソース中の Charset 指定を参照
      - UTF8 に変換後、ヘッダの Charset を UTF-8 にし、コンテンツ中の Charset 指定は削除する
    - レスポンスボディが主要なテキストリソースの場合、Beautify する
      - Beautify して改行数が 2 倍以上になったら、そのリソースは minify されていたと判定する
      - リソースの minify: true とする
    - Resource には mbps を含める。これは
      - (レスポンスボディの長さ / 応答受信開始から完了までの秒) / (1024 \* 1024)
      - 単位は Mbps
- 再生モード
  - Inventory を読み込み、リソースを Transaction に変換する
    - Transaction は、HTTP レスポンスを返すため、事前に処理された情報
    - minify: true の場合は Minify する
    - エンコーディングして、チャンクに分割する
    - チャンクごとの送信開始目標時間(ttfb を含む目標送信オフセット時間)を計算し、targetTime に設定する
  - HTTP プロキシを起動する
    - リクエストを受け取ると、それに対応した Trasaction を探す
    - ttfb の時間だけ処理を待つ
    - その後、チャンクをひとつずつ送信する
      - リクエスト開始からの経過時間が targetTime になるように、チャンクを送信する
      - targetTime に達している場合は即送信し、達していない場合はその時間待つ
- 高速な動作
  - 本プログラムは HTTP プロキシとして動作し、タイミングの制御も重要となる。そのため可能な限り高速に動作させたい。
  - 通常の Web ページの読み込みを想定しているため、大量のデータを扱うことは想定しない。そのためメモリは潤沢に確保してよい。
  - 録画モードでのリソースのメモリ保存や、再生モードで事前にトランザクションへ展開する処理などはそのための設計となっている。

# ライブラリ

一般的なライブラリや、用途に対して主要なライブラリがあれば順次インストールして利用してよい。

# テスト

- コンポーネントに分割し、依存関係を外部注入してテストを容易にしてケースを充実させる。
- ただし DI フレームワークを導入するほどではない。

# 結合テスト

次のように結合テストを行う。この結合テストは CI でも実行するので、依存システムをできるだけ小さく実現する。

- バイナリプログラムをビルドする。
- SSL 対応の静的 Web サーバーを起動し、HTML・CSS・JavaScript からなるシンプルな Web ページをホスティングする。
- ポートと一時ディレクトリのインベントリを指定して録画モードでバイナリプログラムを起動し、Web ブラウザに HTTP プロキシを指定、起動したページにアクセスする。
- バイナリプログラムにシグナルを送り終了する。
- 静的 Web サーバーを停止する。
- inveotyr.json と contents ディレクトリに期待されるリソースが記録されているか確認する。
- ポートとインベントリを指定して再生モードでバイナリプログラムを起動し、Web ブラウザで録画時と同じページにアクセスする。
- 静的 Web サーバーが起動していないにも関わらず、録画時と同じレスポンスが返されることを確認する。

ブラウザは Chrome でもよいが、非常にシンプルなページであるので、もし仮想的なブラウザがあればそれを用いてもよい。
